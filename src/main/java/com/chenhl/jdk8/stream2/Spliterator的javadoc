1.用于对源中元素进行遍历和分区的一个对象。一个分割迭代器Spliterator所涵盖的元素的源可能是一个数组，一个集合，一个生成器函数，或者一个I/O通道。
2.一个分割迭代器可以一个一个的遍历比如tryAdvance()；也可以以块为单位来遍历比如forEachRemaining()
3.一个分割迭代器也可以对它的元素进行分区（使用trySplit）而生成另外的一个分割迭代器，在可能的并行操作中被使用。
使用了分割迭代器的这样一个操作，如果不能分割或者是能分割但是以一种非常不平衡的方式下分割，那么不太可能从并行当中获益。
遍历和分割都会消耗元素，每一个分割迭代器都只是针对当前块计算是有用的。
4.分割迭代器还会报告一个集合它的结构，源，和元素从ORDERED，DISTINCT，SORTED，SIZED，NONNULL，IMMUTABLE，CONCURRENT和SUBSIZED。
这些可以被一个分割迭代器的客户端来使用去控制，特化，或简化计算。比如说，一个集合的分割迭代器将会报告一个SIZED特性；针对于Set集合将会报告一个DISTINCT，一个SortedSet将会报告SORTED。
这些特性值是以bit操作来报告的。
5.有一些特性值会额外的限制方法的行为；比如说ORDERED，遍历方法就必须遵循它们在文档中的顺序，新的特性可以被定义在将来，所以实现者不应该赋予除了上述8个值之外的意义。
6.没有报告IMMUTABLE或CONCURRENT的分割迭代器期望有一个文档化的策略化的一个考量：当分割迭代器绑定到元素的源上时，并且要对元素的源的结构上的修改有一个检测。
一个延迟绑定的分割迭代器会在元素的源上的第一次遍历，第一次分割，或是第一次查询的时候绑定到元素的源上，而不是在分割迭代器创建的时候绑定的。非延迟的分割迭代器是在创建的时候绑定到元素的源上的，
或者是在任意一个方法被调用的时候绑定。如果在绑定之前对源做了修改的话，那么这种修改在分割迭代器遍历的时候就会被反映出来。如果在绑定之后修改的话，会抛出ConcurrentModificationException异常。
分割迭代器遍历块的方法（forEachRemaining()）可以优化遍历并且检查结构上的变化在所有的元素被遍历后。而不是检查每一个元素然后立刻失败。
7.分割迭代器能够提供一个估算剩余元素大小通过estimateSize()这个方法。理想情况下，如果包含了#SIZED的话这个值与随后的遍历所遇到的元素的数量相同，即使不能精确的知道，那么估算的值也是很有用的。
8.尽管这些显著的特性在并行计算中，分割迭代器并不要求是一个线程安全的。相反，使用了分割迭代器的并行算法的实现应该确保在某一时刻只有一个线程来使用，这通常容易获得通过现行线程围栏。
9.分割迭代器的原生的子类型的特化也被提供OfInt，OfLong，OfDouble。Spliterator的tryAdvance和forEachRemaining的子类型的默认实现会包装原生的数据类型到包装类型。
这种包装相对于使用原生类型的特化就失去了性能上的一些优势。为了避免装箱，相应的，基于原生的方法应该被使用。