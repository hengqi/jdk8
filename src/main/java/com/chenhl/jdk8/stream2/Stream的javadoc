1.一个元素的序列，支持串行和并行的聚合操作。
2.例子见javadoc
3.除了Stream之外，是一个对象引用流，还有一些原生的特化的流，IntStream，LongStream，DoubleStream。这些也被称作为“流”，
也遵循流的特性和限制。（JDK提供这些具体的特化的流就是为了减少不必要的拆箱与装箱）
4.在执行一个计算的时候，流操作会被组合到一个流管道当中。一个流管道包含了一个源（可以是数组，集合，一个生成器函数，I/O通道，等等（源就是数据来自哪里））
0个或多个中间操作（转换一个流到另外一个流，比如Strem.filter(Predicate)）和一个终止操作（生成一个结果，或产生副作用（即改变了元素的值），比如Stream.count()或者Stream.forEach(Consumer)）。
流是惰性的；对于源数据的计算只有当终止操作被发起的时候才会被执行，元素被消费仅仅是当需要的时候。
5.集合和流，有一些相似性，但又不同的目标。集合主要关注于它所存储的元素的管理和访问。与之相反，流并未提供一个方式来方法和操作它的元素。
它更关注于声明式的描述它的元素和计算操作（以一种聚合的方式在元素上执行），言外之意：集合关注于元素的存储，流关注于元素的计算。
如果所提供的接口没有我们期望的，那么就可以使用传统的iterator或者spliterator来执行一个控制性的遍历。
6.一个流管道，如上说的widgets,可以被看做对流源的一个查询。除非流被明确的设计为可以并发修改的（像ConcurrentHashMap），否则的话，当被查询的时候可能会产生一个未期望的行为。
7.大多数的流操作都会接受描述用户指定的操作，比如例子中的w -> w.getWeight()；为了能到到一个正确的结果，这些行为参数必须满足一下条件：
    7.1 必须是非冲突，非干扰的，
    7.2 在大多数情况下，必须是无状态的（结果不应该依赖任何状态--可能会被改变在流管道的执行过程中）
8.这些参数总是函数式接口的一个实例比如java.util.function.Function，它们通常是lambda或者方法引用。除非特别指定，否则这些参数必须是非空的。
9.一个流只能被操作一次
10.流实现了close()方法，并且实现了AutoCloseable接口。但是几乎所有的流实例基本上不用去关闭。通常情况下，只有当一个流的源是一个I/O通道，会要求关闭。
大多数流的底层源是一个集合，数组，或生成器函数，他们并不需要过多的资源管理（言外之意，都是内存对象）。如果一个流需要被关闭，它必须被声明为一个资源在try-with-resources块里。
11.流管道可以被执行以串行或并行的方式。这个执行方式是流的一个属性。流被创建的时候，可以选择这种模式。这种模式的选择可以被修改通过方法sequential()和parallel()。也可以通过isParallel来查询。



public interface BaseStream<T, S extends BaseStream<T, S>> S代表的是每个中间操作返回的新的流的类型

public interface Stream<T> extends BaseStream<T, Stream<T>>



流的底层源码层次关系：
ReferencePipeline表示流的源阶段和中间阶段
ReferencePipeline.Head表示流的源阶段

二者在大部属性的设定上都是类似的，但存在一些属性是不同的，比如说Head是没有previousStage的，而ReferencePipeline是存在previousStage的。
